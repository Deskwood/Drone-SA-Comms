ARCHITECTURE / DESIGN — CORASAT v1.3
(precision guard, SuggestedEdges-only, structured comms, DS penalties)

GOAL
Local-only agents with deterministic seams. High precision via intake filtering. Non-global comms. DS steers coverage.

MODULES

1. config

* `load_config(path:str)->dict`

  * Defaults: board, gui, simulation, prompt_requests, figures.
  * `decision_support`: `{enabled, max_depth, max_branching, beam_width, timeout_ms, weights, prefer_top_recommendation=True, include_in_prompt=True, deterministic=True}`
  * DS default weights: `recall=0.6, exploration=0.15, plan_adherence=0.15, move_validity=0.05, comm_opportunity=0.03, precision=0.02`
  * Placeholder substitution: `NUMBER_OF_DRONES`, `DRONE_ID`, `NUMBER_OF_ROUNDS`.

2. loggingx

* `class TimestampedLogger(log_dir='logs', log_file='simulation.log')`

  * `log(msg:str)->None`
  * File+console, never raise.

3. domain

* Constants: `COLORS`, `FIGURE_TYPES`, `DIRECTION_MAP`, `VALID_DIRECTIONS`.
* Helper: `direction_from_vector((dx,dy))->str`
* `class Figure(pos:(int,int), color:str, figure_type:str)`

  * `defended_by:int`, `attacked_by:int`, `target_positions:list[(int,int)]`
  * `calculate_figure_targets(board:Tile[][])->None`  (standard chess)
* `class Tile(x:int, y:int)`

  * `figure:Figure|None`, `drones:list[Drone]`, `targeted_by:{"white":int,"black":int}`
  * `set_figure(f)`, `add_drone(d)`, `remove_drone(d)`, `reset_targeted_by_amounts()`, `add_targeted_by_amount(color,amount=1)`
* Ground truth: `compute_edges_for(figures:list[Figure], board:Tile[][])->set[((x1,y1),(x2,y2))]`

4. io_schema

* `class TurnResult` (Pydantic)

  * `rationale:str`
  * `action: Literal["wait","move","broadcast"]`
  * `direction: Optional[str]`  (required iff `action=="move"`)
  * `message: Optional[str]`    (required iff `action=="broadcast"`)
  * `memory:str`
  * `found_edges: List[List[List[int]]] = []`  (never None)
  * Validators enforce specifier presence and list type.
* JSON helpers:

  * `extract_first_json_block(text:str)->str`
  * `safe_parse_turnresult(payload:str)->dict`  (never raise; coerces `found_edges=[]`)
  * `normalize_edges(raw:any)->set[((int,int),(int,int))]`

5. plan_parser

* Regex accepts: `PLAN:` or `PLAN v\d+;`, both `PATH=` and `D<id>:PATH=`, aliases `{n,s,e,w,ne,nw,se,sw}`
* API:

  * `parse_plan_from_text(text:str, target_id:Optional[int]=None)->list[str]`
  * `update_plan_from_text(plans:dict[int,list[str]], drone_id:int, text:str)->bool`

6. suggested_edges

* Local-only candidate edges using current tile + neighbor occupancy.
* API:

  * `candidate_edges_local(board:Tile[][], pos:(int,int))->list[[[int,int],[int,int]]]`
* Intake precision guard helper:

  * `_is_edge_locally_plausible(board, src:(int,int), dst:(int,int))->bool`
    Rules (first-step only):

    * king: any occupied neighbor
    * pawn: forward diagonals by color if occupied
    * rook/bishop/queen: adjacent along legal rays if occupied
    * knight: false (excluded for locality)

7. decision_support

* Types:

  * `DroneLocalState = { pos:(x,y), allowed_dirs:[str], same_tile_count:int, fig_here:str|None, neighbor_figs:{dir:str}, memory:str, rx_preview:str }`
  * `Recommendation = { action:str, specifier:str|None, score:float, rationale:str, features:{str:float} }`
* Pure scorer:

  * `score_action_sequence(local_state, plan:list[str], sequence:list[(action,spec)], weights:dict)->(score:float, features:dict)`
  * Features: `recall, exploration, plan_adherence, move_validity, comm_opportunity, precision`
  * Penalties: border proximity, repeat last tile, revisit within 2 steps, re-co-location
  * Bonus: stepping onto tile with visible figure color
* Tree:

  * `build_decision_tree(local_state, plan:list[str], cfg:dict)->{tree:dict, recommendations:list[Recommendation]}`
  * Root actions: move(each allowed, alphabetical), broadcast, wait
  * Depth ≤ `max_depth`, prune by `max_branching`, `beam_width`, stop on `timeout_ms`, deterministic ties
* Formatter:

  * `format_decision_support_section(recs:list[Recommendation], plan_next:str|None, k:int=3)->str`  (≤30 lines)

8. llm

* Interface:

  * `chat(model:str, messages:list[{role,content}], temperature:float, format:"json"|None, num_predict:int)->str`
* Implementations: Manual, Ollama
* Retry:

  * First call → parse; on error or missing fields → strict schema hint + doubled `num_predict`; else fallback with `found_edges=[]`
  * If `SuggestedEdges` non-empty and `found_edges` empty on retry, add hint: “Copy SuggestedEdges to found_edges now.”

9. drone

* State: `id:int, position:(int,int), color:str, model:str, rules:str, sim:SimView, memory:str, rx_buffer:str`
* Methods:

  * `_allowed_directions()->list[str]`
  * `_move(direction:str)->bool`  (tile update + log)
  * `_phase()->"Planning"|"Execution"`
  * `_local_state()->DroneLocalState`  (provides `same_tile_count`)
  * `_determine_situation_description()->str`  (fixed lines; clears `rx_buffer`)
  * `_token_budget_total()->int`  (`num_predict = max(1024, budget)`)
  * `generate_full_model_response()->list[messages]`:

    1. Build `situation` via `_determine_situation_description`
    2. DS: `build_decision_tree(local_state, plan_queue, ds_cfg)`; store top rec for gating; if `include_in_prompt`, append `DecisionSupport` section
    3. Compute `se = candidate_edges_local(...)`; append `SuggestedEdges: <json>`
    4. Append strict cue: `"EDGE RULE: Output edges ONLY from SuggestedEdges. If none, set found_edges: []."`
    5. Append `prompt_requests` cues
    6. Build `[{"system":rules},{"user":situation}]`, call LLM with retry
    7. Return transcript (assistant TurnResult dict appended)

10. simulation

* Construction:

  * Load rules (substitute `NUMBER_OF_DRONES`)
  * Build board/figures (randomize if configured), compute GT edges
  * Create drones at base (white king pos else (0,0))
  * Seed memory: `MEM:VISITED=<x,y>`
  * Optional GUI
  * `ThreadPoolExecutor(max_workers=1)`
  * DS cache: `_ds_top_by_drone: dict[int, {action,specifier}|None]`
* Public: `run_simulation()`, `shutdown()`
* Helpers:

  * Phase/Threat/GT: `_rebuild_threat_map()`, `_compute_attack_defense_per_figure()`, `_compute_gt_edges()`
  * Score: `discovered_edges()`, `score_stats()`
  * Plans: `_maybe_update_plan_from_text(drone_id:int, text:str)`, `_next_planned_step(drone_id:int)`, `_advance_plan(drone_id:int)`, `_auto_replan_if_illegal(drone_id:int)`
  * Logging: `_log_edge_line(edge)`, `_log_discovered_edges_incremental()`, `_log_final_summary()`, `post_info(msg)`
  * Turns: `_start_drone_turn(drone)`, `_try_finish_drone_turn(drone)->bool`
* `_try_finish_drone_turn` sequence:

  1. On future done, get TurnResult dict
  2. Update plan from `memory` and `message` via `plan_parser`; `_auto_replan_if_illegal`
  3. **Intake precision guard**:

     * `raw = normalize_edges(result["found_edges"])`
     * Keep only edges with `src == drone.position` and `_is_edge_locally_plausible(board, src, dst)`
     * Discard others and log
     * Merge per-drone
  4. DS gating:

     * If `prefer_top_recommendation=True` and action=move violates plan adherence at root and not DS top → `action="wait"` and log gating
  5. Phase gating:

     * Planning: any move → wait
  6. Plan enforcement:

     * If `enforce_plan=True` and expected exists: accept only exact match; else wait
  7. Execute:

     * `move`: check allowed → `_move()`; advance plan on match
     * `broadcast`: require valid JSON (COM schema); deliver to co-located drones’ `rx_buffer`
     * else wait
  8. Persist non-empty `memory`; ensure `MEM:VISITED=<x,y>` present
  9. Incremental edge logging

10. Log DS recap (top-3, features, executed action, match/mismatch, prune/timeout)

11. Clear `_thinking`, future

12. comms (structured)

* Valid messages:

  * Observation: `{"obs":{"x":X,"y":Y,"here":"<type|None>","neighbors":{"dir":"color",...}}}`
  * Plan: `{"plan":{"next":"dir","queue":["dir",...]}}`
* Receiver merges into **own** memory; simulator does not maintain a global map
* Non-JSON broadcast → treated as wait; log

DATA CONTRACTS

* `DecisionSupport` prompt block:

  ```
  DecisionSupport:
    PlanNext: <dir|None>
    TopRecommendations:
      - (action, specifier, score)
      ...
    WhyTop:
      - <feature=contrib×weight>
      ...
  ```
* `SuggestedEdges` prompt line:
  `SuggestedEdges: [ [[x1,y1],[x2,y2]], ... ]`  (local only)

CONSTRAINTS

* Local-only info in DS, SuggestedEdges, prompts, memory
* One action per turn
* On-board moves only
* `rx_buffer` cleared after inclusion

TEST HOOKS (pure)

* `parse_plan_from_text`
* `candidate_edges_local`
* `_is_edge_locally_plausible`
* `score_action_sequence`
* `normalize_edges`
* `compute_edges_for`
* `_allowed_directions`

SEQUENCES (happy paths)
A) Turn generation

* Drone: build SITUATION → DS recs (+DecisionSupport) → SuggestedEdges (+EDGE RULE) → cues → LLM → TurnResult parsed

B) Turn application

* Sim: plan update → intake filter → gating (phase/plan/DS) → execute or wait → memory persist (VISITED) → log edges → GUI update

REBUILD CHECKLIST

1. Implement `candidate_edges_local` and `_is_edge_locally_plausible`.
2. Add strict “EDGE RULE” to prompt.
3. Enforce JSON broadcasts; add receiver merge.
4. Strengthen DS scorer with penalties/bonuses; enable `prefer_top_recommendation`.
5. Plan parser + `_auto_replan_if_illegal`.
6. Tighten `TurnResult` validators and retry hints.
7. Keep SITUATION line order; never include GT.
