ARCHITECTURE: CORASAT SIMULATION DESIGN (TEXT-ONLY, COPYABLE)

GOAL
Rebuild the provided Python into clear modules with stable contracts so code can be recreated quickly, tested, and extended.

MODULES

1. config

* load_config(path) -> dict
* Applies defaults for: board, gui, simulation, prompt_requests
* Guarantees prompt_requests.schema present
* No side effects beyond file read and dict normalization

2. loggingx

* class TimestampedLogger(log_dir, log_file)

  * log(msg: str) -> None
* Single file + console handlers, safe to call often
* No exceptions propagate

3. domain

* Constants:

  * COLORS = {"white","black"}
  * FIGURE_TYPES = {"king","queen","rook","bishop","knight","pawn"}
  * DIRECTION_MAP: dict[str, (dx,dy)] with 8 king moves
  * VALID_DIRECTIONS = set(DIRECTION_MAP.keys())
* Functions:

  * direction_from_vector((dx,dy)) -> str
* Classes:

  * class Figure(position:(x,y), color:str, figure_type:str)

    * defended_by:int, attacked_by:int, target_positions:list
    * calculate_figure_targets(board: Tile[][]) -> None
  * class Tile(x:int, y:int)

    * figure: Figure|None
    * drones: list[Drone]   (forward-declared protocol)
    * targeted_by: {"white":int,"black":int}
    * set_figure(figure)
    * add_drone(drone) / remove_drone(drone)
    * reset_targeted_by_amounts() / add_targeted_by_amount(color, amount=1)
* Edge helpers:

  * compute_edges_for(figures:list, board:Tile[]) -> set[((x1,y1),(x2,y2))]

4. io_schema

* Pydantic model TurnResult:

  * rationale:str
  * action: "wait"|"move"|"broadcast"
  * direction:str|None
  * message:str|None
  * memory:str
  * found_edges:list|None
* JSON helpers:

  * extract_first_json_block(text:str) -> str  (balanced-brace slice)
  * safe_parse_turnresult(payload:str) -> dict

    * returns dict TurnResult or a safe object: {"rationale":"Parse/validate error: ...","action":"wait","direction":None,"message":None,"memory":""}
  * normalize_edges(raw:any) -> set[((x1,y1),(x2,y2))]

    * accepts [[[x,y],[x,y]]] or {"src":[x,y],"dst":[x,y]} items
    * coerces ints, drops invalid

5. llm

* Interface:

  * chat(model:str, messages:list, temperature:float, format:"json"|None, num_predict:int) -> str
* Implementations:

  * ManualAdapter: copies last user message to clipboard, reads stdin
  * OllamaAdapter: wraps ollama.chat(format="json")
* Retry policy (pure function or method):

  * call once → parse
  * if parse error or missing found_edges:

    * re-ask with strict hint “Output ONLY a single valid JSON object …”
    * double num_predict
    * if still missing found_edges, try to inject [] from extracted JSON
    * else return safe wait with found_edges: []

6. drone

* class Drone

  * id:int
  * position:(x,y)
  * color:str
  * model:str
  * rules:str (placeholders resolved: DRONE_ID, NUMBER_OF_DRONES, NUMBER_OF_ROUNDS)
  * sim: SimView (see sim section)
  * memory:str (persisted)
  * rx_buffer:str (cleared after prompt assembly)
* Methods:

  * allowed_directions() -> list[str]  (bounds-checked from DIRECTION_MAP)
  * move(direction:str) -> bool  (updates tiles; logs; returns success)
  * phase() -> "Planning"|"Execution"  (sim.round vs sim.planning_rounds)
  * determine_situation_description() -> str

    * lines: Phase, Current round number, Board size, My grid coords, Current position, AllowedDirections, Reminder line, Visible drones at position, Visible figure at position, Visible neighboring figures, Memory, Broadcast Rx Buffer
    * clears rx_buffer after inclusion
  * token_budget_total() -> int

    * sum of budgets with cap; clamp min 512; num_predict = max(1024, budget)
  * generate_single_model_response(messages, model, temperature) -> list[messages]

    * appends validated assistant dict to messages using retry policy
  * generate_full_model_response() -> list[messages]

    * builds messages = [{system:rules},{user:situation + cues}]
    * cues = joined prompt_requests fields: schema, rationale, action, action_move, action_broadcast, memory_update

7. sim

* class Simulation

  * Public:

    * run_simulation() -> None
    * shutdown() -> None
  * Construction:

    * reads rules file; substitutes NUMBER_OF_DRONES
    * grid_size = (board.w, board.h)
    * create board: Tile[w][h]
    * create figures from config or randomized via random_seed / randomize_figures
    * rebuild_threat_map(); compute_attack_defense_per_figure(); compute_gt_edges()
    * choose drone_base: white king position else (0,0)
    * create num_drones Drone at base; add to tile
    * gui built if use_gui
    * ThreadPoolExecutor(max_workers=1)
  * State:

    * turn:int, round:int
    * planning_rounds:int, enforce_plan:bool
    * plans: dict[int, list[str]]  (from PLAN:path=… in memory/message)
    * gt_edges:set
    * drone_edges: dict[int, set[((x,y),(x,y))]]
    * _edge_log_seen:set
    * _current_future:Future|None, _thinking:bool
  * Helpers:

    * phase_label() -> "Planning"|"Execution"
    * create_figures()

      * optional randomize_figures_layout(fig_cfg, W, H, seed) -> fig_cfg2
    * rebuild_threat_map()  (clear tallies → compute targets → add tallies)
    * compute_attack_defense_per_figure()  (per-figure counts from tile.tallies)
    * compute_gt_edges()  (domain.compute_edges_for)
    * discovered_edges() -> set  (union over drone_edges)
    * score_stats() -> dict {identified_nodes, discovered_edges, gt_edges, correct_edges, false_edges, score, precision, recall}
    * parse_plan_from_text(text) -> list[str]  (uses regex; aliases n,s,e,w,ne,nw,se,sw)
    * maybe_update_plan_from_text(drone_id, text)
    * next_planned_step(drone_id) -> str|None
    * advance_plan(drone_id)
    * log_edge_line(edge)  (labels CORRECT/FALSE)
    * log_discovered_edges_incremental()  (new vs seen)
    * log_final_summary()  (precision, recall, score; list false edges)
    * post_info(msg)  (GUI-safe)
    * current_drone() -> Drone|None
  * Turn orchestration:

    * start_drone_turn(drone)  → submit drone.generate_full_model_response()
    * try_finish_drone_turn(drone) -> bool

      * if future done:

        * read assistant dict result
        * maybe_update_plan_from_text from memory/message
        * ingest found_edges (normalize_edges) into drone_edges[drone.id]
        * action handling:

          * Planning phase: force wait if action == move
          * Execution:

            * if action == move:

              * require direction in drone.allowed_directions()
              * if enforce_plan and expected exists: only allow if direction == expected else wait
              * if allowed: drone.move(direction); advance_plan if matched
            * if action == broadcast:

              * non-empty message
              * deliver to co-located drones at same tile: append to rx_buffer ("Drone X broadcasted: ...\n")
            * else wait
        * persist memory if non-empty
        * log_discovered_edges_incremental()
        * GUI log lines
        * clear thinking, clear future, return True
      * else False
  * Main loop (run_simulation):

    * event pump (QUIT/ESC)
    * captions: "Simulation - Round r.t / R.D"
    * if not pending: set round/turn; start future; pending=True
    * if pending and finished: advance drone_index; roll round; pending=False
    * draw GUI each tick; 60 FPS
    * after loop: log_final_summary(); shutdown()

8. gui

* class SimulationGUI(sim)

  * draw_field(): grid, figures, overlay “D{def} A{att}”, drones as circles with id, highlight current while thinking
  * draw_sidebar(): score panel + plan preview + log scroller
  * post_info(text) appends to side log
  * image cache by cell size; loads from gui.figure_image_dir
* Pure view, no logic

CONSTRAINTS ENFORCED

* Moves limited to VALID_DIRECTIONS and board bounds
* One action per turn
* Planning phase disables movement
* Broadcast only to co-located drones; read next turn; rx_buffer cleared after inclusion in prompt
* No ground-truth leakage
* All R rounds execute (no early termination in loop)

PROMPT CONTENT CONTRACT (SITUATION STRING ORDER)

1. Phase: <Planning|Execution>
2. Current round number: <int>
3. Board size: <W>x<H> (x=0..W-1, y=0..H-1)
4. My grid coords: x=<int>, y=<int>
5. Current position: (<x>, <y>)
6. AllowedDirections: [dir...]
7. Reminder: You MUST pick 'direction' only from AllowedDirections when action=='move'.
8. Visible drones at position: <list|None>
9. Visible figure at position: <type|None>
10. Visible neighboring figures: <compass: color, ...|None>
11. Memory: <string>
12. Broadcast Rx Buffer: <string>

TURNRESULT CONTRACT (DICT AFTER VALIDATION)

* action in {"wait","move","broadcast"}
* if action=="move": direction in drone.allowed_directions()
* if action=="broadcast": message non-empty
* memory is str (persist non-empty)
* found_edges present for scoring (inject [] if missing)

SCORING

* discovered_edges = union of all drone_edges
* gt_edges computed from figures’ target squares that contain figures
* precision = |correct| / |discovered|, recall = |correct| / |gt|
* score = |correct| - |false|
* incremental logging of new edges

ERROR HANDLING

* Any parse or adapter error → safe wait TurnResult
* Invalid or OOB move → wait, logged
* Broadcast with empty message → wait, logged
* GUI failures do not crash sim; catch and continue
* Shutdown cancels futures, closes pygame, logs completion

EXTENSION POINTS

* Swap LLM backend by implementing chat interface
* Add token/cost accounting
* Replace SITUATION string with structured object + renderer
* Add confidence to found_edges without breaking normalization
* Enable multi-agent parallelism by increasing executor and adding locking (not needed now)

TEST PLAN
Unit

* allowed_directions on corners/edges/center
* move valid/invalid/OOB transitions update tiles
* safe_parse_turnresult: valid JSON, prose+JSON, malformed JSON
* normalize_edges: both schemas, invalid entries dropped
* parse_plan_from_text: alias mapping, invalid tokens dropped
* compute_edges_for small fixed setups
* token_budget_total clamping

Integration

* Co-located broadcast → appears in rx_buffer next turn → cleared after prompt
* Planning vs execution gating and plan enforcement
* Edge ingestion updates precision/recall deterministically
* GUI renders with and without images

Property

* Randomized figure layouts with seeds → stable gt_edges
* Fuzz LLM outputs → system never crashes; degrades to wait

REBUILD CHECKLIST

1. Implement config.load_config with defaults exactly as specified
2. Implement loggingx.TimestampedLogger
3. Implement domain (constants, Figure, Tile, helpers)
4. Implement io_schema (TurnResult, extract_first_json_block, safe_parse_turnresult, normalize_edges)
5. Implement llm adapters and retry policy
6. Implement drone with exact SITUATION line order and rx_buffer clearing
7. Implement sim orchestration, plan parsing, scoring, logging
8. Implement gui view
9. Wire rules.txt substitution (DRONE_ID, NUMBER_OF_DRONES, NUMBER_OF_ROUNDS in Drone.rules; NUMBER_OF_DRONES in Simulation.rules)
10. Keep single-thread executor semantics
11. Add unit and integration tests before optimizer work
